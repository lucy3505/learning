/*

    函数被外部变量所引用
    *当函数可以记住并访问所在得词法作用域时，就产生了闭包，即 使函数是在当前词法作用域之外执行。
    function foo(){
        var a = 2;
        function bar(){
             var b = 1
            console.log(b)
            console.log(a)//!这句才产生了闭包,没有这句就没有闭包，上面那句不产生闭包，没有引用外部变量
        }
        bar()
    }
    foo()
    ?这是闭包吗？
    技术上来讲，也许是。但根据前面得定义，确切的说并不是。准确得解释是bar()对a得引用得方法是词法作用域得查找规则，而这些规则只是闭包得一部分。
    函数bar()具有一个涵盖foo()作用域得闭包(事实上，涵盖了它能访问得所有作用域)。也可以认为bar()封闭在了foo()得作用域中。
    ?为什么呢？
    因为bar()嵌套在foo()内部
    下面代码清晰地展示了闭包：
    function foo(){
        var a = 2;
        function bar(){
            var b = 1
            console.log(b)
            console.log(a)//!这句才产生了闭包,没有这句就没有闭包，上面那句不产生闭包，没有引用外部变量
        }
        return bar
    }
    var baz=foo()
    baz() //这就是闭包得效果
    见 closure.jpg
    bar()显然可以被正常执行。//^但是在这个例子中，它在自己定义得词法作用域意外得地方执行
    在foo()执行后，通常会期待foo()得整个内部作用域被销毁，因为引擎有垃圾回收器用来释放不再使用得内存空间。由于看上去foo()内容不会再被使用，所以很自然考虑对其进行回收。
    而闭包得“神奇”之处是可以阻止这件事情（垃圾回收器）得发生。事实上内部作用域依然存在，因此没有被回收。
    ?谁在使用这个内部作用域？原来是bar()本身在使用。
    拜bar()所声明得位置所赐，它拥有涵盖foo()内部作用域得闭包，使得该作用域能够一直存活，以供bar()在之后任何时候进行引用。
    bar()依然持有对该作用域得引用，而这个引用就叫做闭包。这个函数在定义时得词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。
    无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。
    function foo(){
        var a = 2;
        function baz(){
            console.log(a)
        }
        bar(baz)
    }
    function bar(fn){
        fn()//这就是闭包
    }
    foo()

^传递函数可以是间接的
var fn
function foo(){
    var a = 2;
    function baz(){
        console.log(a)
    }
    fn=baz
}
function bar(){
    fn() //这是闭包
}
foo()
bar()
^无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。
*本质上无论何时何地，如果将（访问他们各自词法作用域的）函数当作第一级的值类型并导出传递，你就会看到闭包在这些函数中的应用。在定时器/时间监听/ajax请求，跨窗口通信，Web Woekers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包。







 */