<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
    <div id='root'></div>
    <script src="./react.js"></script>
    <script src="./react-dom.js"></script>
    <script src="./babel.min.js"></script>
    <script type="text/babel">

    class App extends React.Component{
      constructor(props){
        super(props)
        this.state={
          content:'初始化的content内容'
        }
        console.log('父组件App的构造函数被调用了')
      }
      componentWillMount() {
        console.log('父组件App即将挂载。。。。componentWillMount')
      }
      changeContent=()=>{
        this.setState({
          content:'修改后的conten内容'
        })
      }
      render(){
        console.log('父组件App的render函数....')
        return (
          <div>
            <p>App组件的状态：{this.state.content}</p>
            <button onClick={this.changeContent}>修改App的content状态</button>
            <hr/>
            <Child myContent={this.state.content} />
          
          </div>

        )
      }
      componentDidMount(){
        console.log('父组件App挂载完成。。。。componentDidMount')
      }
      shouldComponentUpdate(nextProps,nextState){
        console.log('父组件shouldComponentUpdate被调用')
        return true
      }
      componentWillUpdate() {
        console.log('父组件的即将更新...componentWillUpdate')
      }
      componentDidUpdate(prevProps,prevState) {
        console.log('父组件更新完成....componentDidUpdate')
      }
      componentWillReceiveProps(nextProps){
        //这个函数被调用是有条件的：被某组件（父组件）的子组件，只要某组件更新了，那么子组件就会促发这个钩子函数，不管有没有传值过来。所以一般来说也只有最外层的App不会触发到这个函数，因为它是顶级组件
        //当前父组件的render函数被调用后自动会回调子组件的该生命钩子函数
        console.log('父组件Child的componentWillReceiveProps被调用....')
      }
      componentWillUnmount() {
        console.log('父组件即将卸载....componentWillUnmount')
      }
     
    }

    class Child extends React.Component{
      //子组件的生命周期

      //挂载阶段
      constructor(props){
        super(props)
        console.log('子组件Child的构造函数被调用了')
        this.title="hello" //普通数据
      }
      componentWillMount() {
        console.log('子组件Child即将挂载。。。。componentWillMount')
      }
      render(){
        console.log('子组件Child的render函数....')
        return (
          <div>

            <p>子组件获取到的父组件属性:{this.props.myContent}</p>
            <h3>子组件的普通数据:{this.title}</h3>
            <button onClick={this.changeTitle}></button>
          </div>

        )
      }
      this.changeTitle=()=>{
        this.title="zhangsan"
        this.forceUpdate() //强制更新视图
      }
      componentDidMount(){
        console.log('子组件Child挂载完成。。。。componentDidMount')
      }

      //更新阶段  如果是自己的一个setState,就会进入shouldComponentUpdate 这个一旦显示写出来就要返回true，否则就终止了
          //相较于修改自身的setState更新多了一个回调函数componentWillReceiveProps，这个函数用于接收父组件传过来的props发生变化时用的，如果父组件传过来的props发生了变化，那么首先进入componentWillReceiveProps
      componentWillReceiveProps(nextProps){
        //当前父组件的render函数被调用后自动会回调子组件的该生命钩子函数
        console.log('子组件Child的componentWillReceiveProps被调用....')
        //不管父组件是否有props传递给子组件，只要父组件的模板使用子组件
        //则更新时父组件的render调用一次都会自动导致子组件的componentWillReceiveProps调用
      }

      shouldComponentUpdate(nextProps,nextState){
        console.log('子组件shouldComponentUpdate被调用。。。')
        return true
      }
      componentWillUpdate() {
        console.log('子组件的即将更新...componentWillUpdate')
      }
      componentDidUpdate(prevProps,prevState) {
        console.log('子组件更新完成....componentDidUpdate')
      }
      //卸载
      componentWillUnmount() {
        console.log('子组件即将卸载....componentWillUnmount')
      }

    }
    
    //上面定义好了，真正的路口在下面，ReactDOM.render
    ReactDOM.render(<App title="hello,world"/>,document.getElementById('root'))
    //进入App---首先实例化App进入后调用componentWillMount()然后render(),，这时候碰到child组件，会先进去实例化Child组件，调用Child的componentWillMount,render(),compoentDidMount,然后再回来调用父组件的componentDidMount

    //卸载组件
    setTimeout(()=>{
      //解绑组件
      ReactDOM.unmountComponentAtNode(document.getElementById('root'))
    })

    </script>
  
</body>
</html>