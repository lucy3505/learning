/* 
    ``程序中的一段源代码再执行之前会经历三个步骤，统称为“编译”
    1.分词/词法分析：这个过程会将由字符组成的字符串分解成由意义的代码块，这些代码块会被称为词法单元（token).例如：考虑程序var a=2；这段程序通常会被分解成为下面这些//*词法单元： var,a,=,2
        分词和词法分析之间的区别是非常微妙的，主要差异在于//*词法单元
        的识别是通过有状态还是无状态的方式进行的。
    2.解析/语法分析
        这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被成为“抽象语法树”（Abstract Syntax Tree,AST)
    3.代码生成
        将AST转换为可执行代码的过程被成为代码生成。这个过程与语言，目标平台等息息相关。
        简单来说就是有某种方法可以将var a = 2的AST转化成一组机器指令，用来创建一个叫做a的变量（包括分配内存等），并将一个值储存再a中
        *引擎可以根据需要创建并存储变量
``1.2理解作用域
    1.2.1演员表
    1.引擎
        从头到尾负责整个js程序的编译及执行过程
    2.编译器
    引擎的好朋友之一，负责语法分析及代码生成等脏活累活
    3.作用域
        引擎的另一位好朋友，负责收集并维护由//*所有声明的标识符（变量）组成的一系列查询，
        并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
1.2.2对话
当看到var a=2，引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。
1）编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构，但是当编译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。
    可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：“//*为一个变量分配内存，将其命名为a,然后将其值2保存进这个变量”，
    然而，这并不完全正确。
    1）遇到var a，编译器会询问作用域是否有一个该名称的变量存在于同一个作用域的集合中，如果是，编译器就会忽略该声明，继续进行编译，否则它会//*要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。
    2）接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a=2这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做a的变量，如果是，引擎就会使用这个变量，如果否，引擎会继续查找该变量。
    总结：//*变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后再运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。
1.2.3编译器
编译器在编译过程中的第二步中生成了代码，引擎执行它时，会通过查找变量a来判断它是否已声明过，查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。
当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询
!RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。
从这个角度说，RHS并不是真正意义上的‘赋值操作的右侧“，更准确地说是“非左侧”。
可以将RHS理解成retrieve his source value,这意味着"得到某某的值“。
console.log(a);
其中对a的引用是一个RHS引用，因为这里a并没有赋予任何值。相应地，需要查找并取得a的值。
LHS和RHS最好将其理解为”赋值操作的目标是谁（RHS）以及“谁是赋值操作的源头（RHS)”
 */